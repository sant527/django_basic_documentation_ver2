"""
Django settings for basic_django project.

Generated by 'django-admin startproject' using Django 2.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/2.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.2/ref/settings/
"""

import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

#################

#using .env to store important info and keep single settings.py file and change
#the .env variables as per development and production requirements

#if we use  (e.g env('ALLOWED_HOSTS')) in the settigns.py it has to be mentioned
#in .env file even we keep the variable empty in the .env else it will show
#error. Thats why we use environ.Env( ALLOWED_HOSTS=(list, ['127.0.0.1:8000']))
#to set default value in the settings.py in case its left empty.

#For accessing env variables from .env inside settings.py 
#step 1
import environ

#step 2
# define env as below. Here mention all the defaults we want to have if we leave
# variables empty in .env file. But this will not check if the variable is
# defined in .env file or not
env = environ.Env(
    # set casting, default value
    DEBUG=(bool, False),
    ALLOWED_HOSTS=(list, ['127.0.0.1:8000']),
)

# step 3
# reading .env file
environ.Env.read_env()

#step 4
#getting the env variable value from the KEY. This will check the .env
#file for the variable. If its not defined then it will show error. If its empty
#and its default is defined then it pics the default value else shows empty. 
#Eg: SECRET_KEY = env('SECRET_KEY')

##################


# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = env('DEBUG')

ALLOWED_HOSTS = env('ALLOWED_HOSTS')


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'custom_user',
    'login_register_password',
    'articles',
    'webpack_loader',
]

if DEBUG: 
     INSTALLED_APPS += [  'django_extensions']


MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

if DEBUG:
    MIDDLEWARE += ['querycount_mod.middleware.QueryCountMiddleware']

if DEBUG:
    QUERYCOUNT = {
        'THRESHOLDS': {
            'MEDIUM': 50,  ## Color setting: If a query is repeated more than this number then it will be shown in bold brown else light brown
            'HIGH': 100,  ## Color setting: If a query is repeated more than this number then it will be shown in red
            'MIN_TIME_TO_LOG':0, ## If the total time for query is less than this then it will show
            'MIN_QUERY_COUNT_TO_LOG': 0 ## If the total number of queries is less than this then it will show
        },
        'IGNORE_REQUEST_PATTERNS': [],
        'IGNORE_SQL_PATTERNS': [],
        'DISPLAY_DUPLICATES': 10000, ## Numer of queries whose sql to be displayed Note: Every query is considered as duplicate even its is executed once. It is considered as repeated as once. We are using 10,000 because we want to see the all the queries
        'RESPONSE_HEADER': 'X-DjangoQueryCount-Count'
    }


ROOT_URLCONF = 'basic_django.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'basic_django.wsgi.application'


# Database
# https://docs.djangoproject.com/en/2.2/ref/settings/#databases

### DATABASES = {
###     'default': {
###         'ENGINE': 'django.db.backends.sqlite3',
###         'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
###     }
### }

DATABASES = {
    # read os.environ['DATABASE_URL'] and raises ImproperlyConfigured exception if not found
    'default': env.db(),  
    # env.db() is a short form of env.db(â€˜DATABASE_URL', default='psql:////tmp/my-tmp-sqlite.db')
}

WEBPACK_LOADER = {
    'DEFAULT': {
        'BUNDLE_DIR_NAME': '',  #we want to have multiple entry in webpack so we keep this blank.
        'STATS_FILE': os.path.join(BASE_DIR, 'webpack-stats.json'),
        #BASE_DIR is your Django project directory. The same directory where manage.py is located.
    }
}



# Password validation
# https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/2.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.2/howto/static-files/

STATIC_URL = '/static/'

AUTH_USER_MODEL = 'custom_user.User'

# Configuring smtp with gmail account
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_USE_TLS = True
EMAIL_USE_SSL = False
EMAIL_PORT = 587
EMAIL_HOST_USER = env('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = env('EMAIL_HOST_PASSWORD')

# Testing mail to which we will send the emails to
TESTING_EMAIL=env('TESTING_EMAIL')

# we want to use this mainly to show in github any example
TESTING_EMAIL2="test@xyz.com"

#By default, Django will only display messages with level greater than 20
#(INFO). If you want to display DEBUG messages:
MESSAGE_LEVEL = 10  # DEBUG


#######################################################
# Logging objects, sql, traceback and strings
#######################################################

import logging
import traceback

# Verbose formatter to be used for the handler used in logging "custom_string"
class VerFormatter(logging.Formatter):
    def format(self, record):
        ## We want to show some code lines while logging. So that its eays to know 
        #create a list of all the linenumber: lines 
        lines=[]
        with open(record.pathname) as src:
            for index, line in enumerate(src.readlines(), start=1):
                if index == record.lineno:
                    lines.append('{:4d}***: {}'.format(index, line))
                else:
                    lines.append('{:7d}: {}'.format(index, line))
        # select +/-3 lines from the current line
        start=(record.lineno -1) - 5
        end=(record.lineno -1) + 5
        if record.lineno == len(lines):
            end = record.lineno-1
        if end > len(lines)-1:
            end = len(lines)-1
        if record.lineno -1 == 0:
            start = 0
        if start < 0:
            start = 0
        code = ''.join(lines[start:end+1]) #lines[start:length]

        # colorize the code
        import pygments
        from pygments.lexers.python import Python3Lexer
        from pygments.formatters import TerminalTrueColorFormatter
        code = pygments.highlight(
            code,
            Python3Lexer(),
            #TerminalTrueColorFormatter(style='monokai')
            TerminalTrueColorFormatter()
        )

        #add new attributes to record which will be used later
        record.codelines = code
        record.topline = "--------------------------------------------------------------------------------------------------------------"
        record.botline = "--------------------------------------------------------------------------------------------------------------"
        return super(VerFormatter, self).format(record)


# SQL formatter to be used for the handler used in logging "django.db.backends"
class SQLFormatter(logging.Formatter):
    def format(self, record):

        # Check if Pygments is available for coloring 
        try:
            import pygments
            from pygments.lexers import SqlLexer
            from pygments.formatters import TerminalTrueColorFormatter
        except ImportError:
            pygments = None

        # Check if sqlparse is available for indentation
        try:
            import sqlparse
        except ImportError:
            sqlparse = None

        # Remove leading and trailing whitespaces
        sql = record.sql.strip()

        if sqlparse:
            # Indent the SQL query
            sql = sqlparse.format(sql, reindent=True)

        if pygments:
            # Highlight the SQL query
            sql = pygments.highlight(
                sql,
                SqlLexer(),
                #TerminalTrueColorFormatter(style='monokai')
                TerminalTrueColorFormatter()
            )

        # Set the record's statement to the formatted query
        record.statement = sql
        return super(SQLFormatter, self).format(record)



### Change this to closed when there are too many queries going on.and use 
### logger_database.filters[0].open() INDSIDE THE views function not on the top
LoggerGate_Default_State="open"


# Filter class to stop or start logging for "django.db.backends"
class LoggerGate:
    def __init__(self, state=LoggerGate_Default_State):
        # We found that the settings.py runs twice and the filters are created twice. So we have to keep only one. So we delete all the previous filters before we create the new one
        import logging
        logger_database = logging.getLogger("django.db.backends")
        try:
            for filter in logger_database.filters:
                logger_database.removeFilter(filter)
        except Exception as e:
            pass
        self.state = state

    def open(self):
        self.state = 'open'

    def close(self):
        self.state = 'closed'

    def filter(self, record):
        """
        Determine if the specified record is to be logged.

        Is the specified record to be logged? Returns 0/False for no, nonzero/True for
        yes. If deemed appropriate, the record may be modified in-place.
        """
        if self.state == 'open':
            print('\n')
            print('##############################################################################################################')
            print('SQL QUERIED')
            print('##############################################################################################################')
            print('\n')
            print(pp_traceback(traceback.format_stack(limit=20)))
            print('\n')     
        return self.state == 'open'

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'sql': {
            '()': SQLFormatter,
            'format': '[%(duration).3f] %(statement)s',
        },
        'verbose': {
            '()': VerFormatter,
            'format': '%(topline)s\n%(asctime)s\nXXX%(levelname)sXXX %(funcName)s() %(pathname)s[:%(lineno)s] %(name)s \n%(topline)s\n\n%(message)s\n\n%(codelines)s',
            #'datefmt': "[%d/%b/%Y %H:%M:%S %p %Z]"
        },
        'django.server': {
            '()': 'django.utils.log.ServerFormatter',
            'format': '[{asctime}] {message}\n\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n############################################################################################\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n',
            'datefmt' : '%Y-%m-%d %H:%M:%S',
            'style': '{',
            }
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'formatter': 'verbose',
            'class': 'logging.StreamHandler',
        },
        'sql': {
            'class': 'logging.StreamHandler',
            'formatter': 'sql',
            'level': 'DEBUG',
        },
        'django.server': {
            'class': 'logging.StreamHandler',
            'formatter': 'django.server',
        },
    },
    'filters': {
        'myfilter': {
            '()': LoggerGate,
        }
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['sql'],
            'level': 'DEBUG',
            'propagate': False,
            'filters': ['myfilter']
        },
        'django.db.backends.schema': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'custom_string': {
            'level': 'DEBUG' if DEBUG else 'INFO',
            'handlers': ['console'],
            'propagate': False,
        },
        'django.server':{
            'handlers': ['django.server'],
            'propagate': False,
        }

    }
}


#######################################################
# Pretty printing object and sql by various means
#######################################################

# This function is used to pretty print anything as a str.
# Eg: 
### USING WHILE LOGGING
###    ## LOGGING
###    import logging
###    import traceback
###    logger_custom_string = logging.getLogger("custom_string")
###    from basic_django import settings as settings_basic_django
###    #usage1: To show anything as string
###    #logger_custom_string.debug(settings_basic_django.anything("Hare Krishna",traceback.format_stack(limit=5)))
###
### USING WITH PRINT
###    ## LOGGING
###    import logging
###    import traceback
###    from basic_django import settings as settings_basic_django
###    print(settings_basic_django.anything("Hare Krishna",traceback.format_stack(limit=5)))
def anything(var,trace):
    trace_hightligh = pp_traceback(trace)
    str3 = '\n\n'.join([str(var), trace_hightligh])
    return str3

# The below function converts any byte string keys into string
#we found that if key is byte string then json.dumps will throw error So we have to convert the dict
# recursive key as string conversion for byte keys
#https://stackoverflow.com/a/57014404/2897115
def keys_string(d):
    rval = {}

    # Sometimes the object is not a dict it can be list and also. So 
    # Eg:
    ## '_preconf_set_by_auto': {'result_backend', 'broker_url'}
    ## the above will raise error: AttributeError: 'str' object has no attribute 'items'
    ## list = [1,3,4] To declare a tuple, we use brackets.
    ## tuples = (1, 2, "a") To declare a tuple, we use parentheses.
    ## sets = {1,2,3} declare a set. Use curly braces 
    # So we check whether its a dict and then its a tuple,list,set
    if not isinstance(d, dict):
        if isinstance(d,(tuple,list,set)):
            v = [keys_string(x) for x in d]
            return v
        else:
            return d

    # we have to store the keys in a list else some objects give dictionary
    # changed size during iteration error
    # https://stackoverflow.com/questions/59662479/python-error-dictionary-changed-size-during-iteration-when-trying-to-iterate
    keys = list(d.keys())
    for k in keys:
        v = d[k]
        if isinstance(k,bytes):
            k = k.decode()
        if isinstance(v,dict):
            v = keys_string(v)
        elif isinstance(v,(tuple,list,set)):
            v = [keys_string(x) for x in v]
        rval[k] = v
    return rval


# in json_dumps we can pass a default function
def json_dumps_default(obj):
    repr_obj = repr(obj)
    str_obj = str(obj)

    if repr_obj == str_obj:
        return repr_obj
    else:
        return repr_obj,f"STR: {str_obj}"

# If the obj is not dict.tuple,list,set then we categorize the dir(obj)
def pp_odir_getobject(obj):
    if isinstance(obj,dict):
        return keys_string(obj)
    if isinstance(obj,(tuple,list,set)):
        return keys_string(obj)

    #c_dict = {k: getattr(obj, k) for k in dir(obj)} # this gives all the properties listed using dir(c)

    # we are not using the above is because if there are except it stops
    c_dict = {
                '00_METHODS********************************************************************************':{},
                "01_UNDESCORE******************************************************************************":{},
                "02_OTHERS*********************************************************************************":{},
                "03_EXCEPTIONS*****************************************************************************":{},
                }
    for key in dir(obj):
        try:
            attr_obj = getattr(obj, key)
            if callable(attr_obj):
            #if inspect.ismethod(attr_obj):
                c_dict['00_METHODS********************************************************************************'][key] = attr_obj
            else:
                if key.startswith("_"):
                    c_dict['01_UNDESCORE******************************************************************************'][key] = attr_obj
                else:
                    c_dict['02_OTHERS*********************************************************************************'][key] = attr_obj
        except Exception as x:
            c_dict['03_EXCEPTIONS*****************************************************************************'][key] = x
    return keys_string(c_dict)


# pretty print using dir(obj) and then its properties and also the traceback
def pp_odir(obj,trace):

    ##  json.dumps(queryset) in Jupyter runs lot of sqls if the object is query set so we want to avoid that. It work fine with views.py
    ## .So we want to stop logging before json_str and continue back with its state after
    import logging
    logger_database = logging.getLogger("django.db.backends")
    try:
        log_filt_state=logger_database.filters[0].state
        logger_database.filters[0].close()
    except:
        pass

    # we have to do two things 1) is to convert any byte strings to keys and also segrate into methods,underscore and other and exceptions
    c_dict_flattened = pp_odir_getobject(obj)

    import json
    from pygments import highlight
    from pygments.lexers import JsonLexer
    from pygments.formatters import TerminalTrueColorFormatter
    #Before passing the dict we want to avoid any byte string keys so keys_string(c_dict)
    json_str=json.dumps(c_dict_flattened, indent=4, sort_keys=True, default=json_dumps_default)

    try:
        # based on the logging status continue after    
        if log_filt_state == 'open':
            logger_database.filters[0].open()
    except:
        pass

    highlight_obj = highlight(json_str, JsonLexer(), TerminalTrueColorFormatter())
    trace_hightligh = pp_traceback(trace)
    str3 = '\n\n'.join([highlight_obj, trace_hightligh])
    return str3


def pp_sql_sql(sql):
    import sqlparse
    import pygments
    from pygments.lexers import SqlLexer
    from pygments.formatters import TerminalTrueColorFormatter
    # format using sqlparser
    sql = sqlparse.format(sql, reindent=True)
    # color it using pygments
    sql = pygments.highlight(sql,SqlLexer(),TerminalTrueColorFormatter())
    return sql

# pretty print sql query from queryset using mogrify(available only for Psycopg)
# Advantage: It does not execute any sql to get the sql
def pp_sql_query_pg(qs):
    from django.db import connections
    # Get a cursor tied to the database of queryset
    cursor = connections[qs.db].cursor()

    # Get the query SQL and parameters to be passed into psycopg2
    query, params = qs.query.sql_with_params()

    # use mogrify: Return a query string after arguments binding. The string returned is exactly the one that would be sent to the database running the execute() method or similar.
    # mogrify is not a method defined by the Python DB API, but instead an add-on of the Psycopg driver. It does not exist for MySql
    sql = cursor.mogrify(query, params)

    # Then format it using sqlparser and color it using pygment
    import sqlparse
    import pygments
    from pygments.lexers import SqlLexer
    from pygments.formatters import TerminalTrueColorFormatter
    # format using sqlparser
    sql = sqlparse.format(sql, reindent=True)
    # color it using pygments
    sql = pygments.highlight(sql,SqlLexer(),TerminalTrueColorFormatter())
    return sql

#pretty print sql query from queryset if Psycopg is not installed (or using database other then postgresql)
# Disadvantage: runs an additional sql query with EXPLAIN
def pp_sql_query_any(qs):
    from django.db import connections
    # Get a cursor tied to the database of queryset
    cursor = connections[qs.db].cursor()

    # Get the query SQL and parameters to be passed into psycopg2
    query, params = qs.query.sql_with_params()

    # Execute the sql
    cursor.execute('EXPLAIN ' + query, params)

    # then get the last executed sql query
    sql = str(cursor.db.ops.last_executed_query(cursor, query, params))

    # Just for confirmation
    assert sql.startswith('EXPLAIN ')

    # Then format it using sqlparser and color it using pygment
    import sqlparse
    import pygments
    from pygments.lexers import SqlLexer
    from pygments.formatters import TerminalTrueColorFormatter
    # format using sqlparser
    sql = sqlparse.format(sql, reindent=True)
    # color it using pygments
    sql = pygments.highlight(sql,SqlLexer(),TerminalTrueColorFormatter())
    return sql


#######################################################
# Pretty printing traceback format_stack###
#######################################################

def pp_traceback(traceback_format_stack):
    import pygments
    from pygments.lexers import Python3TracebackLexer
    from pygments.formatters import TerminalTrueColorFormatter
    traceback_string = ''.join(traceback_format_stack)
    traceback_color = pygments.highlight(traceback_string,Python3TracebackLexer(),TerminalTrueColorFormatter(style='trac')) # trac or rainbow_dash
    return traceback_color



###    ###############################
###    #USAGGE################
###    ## LOGGING
###    import logging
###    import traceback
###    logger_custom_string = logging.getLogger("custom_string")
###    from basic_django import settings as settings_basic_django
###    #usage1: To show anything as string
###    #logger_custom_string.debug(settings_basic_django.anything("Hare Krishna",traceback.format_stack(limit=5)))
###    #usage2: to show dict or obj
###    #logger_custom_string.debug(settings_basic_django.pp_odir(locals(),traceback.format_stack(limit=5)))
###    #logger_custom_string.debug(settings_basic_django.pp_odir(obj,traceback.format_stack(limit=5)))  # This will pretty print all the properties from dir(obj)
###    #sql = str(user_set.query)
###    #sql = user_set.query.__str_s_()
###    ##logger_custom_string.debug(settings_basic_django.pp_sql_sql(sql)) # pretty print the sql obtained from the .query
###    ##logger_custom_string.debug(settings_basic_django.pp_sql_query_pg(user_set)) # pretty print the sql using mogrify only possible with Psycopg
###    ##logger_custom_string.debug(settings_basic_django.pp_sql_query_any(user_set)) # pretty print the sql using EXPLAIN. But runs extra sql
###    #import traceback
###    ##logger_custom_string.debug(settings_basic_django.pp_traceback(traceback.format_stack(limit=5))) #test traceback
###    logger_database = logging.getLogger("django.db.backends")
###    #usage:  (USE THIS INDSIDE THE views function not on the top.)
###    #logger_database.filters[0].open()
###    #logger_database.filters[0].close()

#######################################################
# Get ip address
#######################################################

def get_client_ip(request):
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


